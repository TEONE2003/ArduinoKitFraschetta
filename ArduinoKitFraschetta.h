#ifndef ArduinoKitFraschetta_h
#define ArduinoKitFraschetta_h
#include "EEPROM.h"
#include "Servo.h"
#include "Stepper.h"

enum UNITA_DI_TEMPO:unsigned long {
MICROSECONDI=1,MILLISECONDI=1000,SECONDI=1000000,MINUTI=60000000
};
class CRONOMETRO{
protected:
boolean CRONOMETRO_ATTIVO;
unsigned long T0;
UNITA_DI_TEMPO UNITA_DI_TEMPO_CRONOMETRO;
public:
void IMPOSTA_UNITA_DI_TEMPO(UNITA_DI_TEMPO UNITA_DI_TEMPO_CRONOMETRO){
this->UNITA_DI_TEMPO_CRONOMETRO = UNITA_DI_TEMPO_CRONOMETRO;
}
CRONOMETRO(UNITA_DI_TEMPO UNITA){IMPOSTA_UNITA_DI_TEMPO(UNITA);}
void AVVIA(){
CRONOMETRO_ATTIVO=1;
T0 = micros();
}
void STOPPA(){
CRONOMETRO_ATTIVO=0;
}
unsigned long TEMPO_PASSATO(){
if(CRONOMETRO_ATTIVO){return (micros()-T0)/UNITA_DI_TEMPO_CRONOMETRO;}
else{return 0;}
}
};

class TIMER:CRONOMETRO{
  protected:
  unsigned long RITARDO;
  public:
void ABILITA(){AVVIA();}
void DISABILITA(){STOPPA();}
unsigned long TEMPO_PASSATO_FINO_AD_ORA(){return TEMPO_PASSATO();}
void IMPOSTA_RITARDO_E_UNITA_DI_TEMPO(unsigned long RITARDO,UNITA_DI_TEMPO UNITA){
IMPOSTA_UNITA_DI_TEMPO(UNITA);
this->RITARDO=(RITARDO*UNITA_DI_TEMPO_CRONOMETRO)/UNITA_DI_TEMPO_CRONOMETRO;
}
boolean STOP(){
if(TEMPO_PASSATO()>=RITARDO){DISABILITA();return 1;}
return 0;
}
TIMER():CRONOMETRO(MICROSECONDI){}
TIMER(unsigned long RITARDO,UNITA_DI_TEMPO UNITA):CRONOMETRO(UNITA){
    IMPOSTA_RITARDO_E_UNITA_DI_TEMPO(RITARDO,UNITA);
}
};

class CICLO_TIMER:TIMER{
protected:
  boolean NON_ABILITATO=1;
public:
  boolean INIZIALIZZATO;
  CICLO_TIMER(unsigned long RITARDO,UNITA_DI_TEMPO UNITA):TIMER(RITARDO,UNITA){INIZIALIZZATO=1;}
  CICLO_TIMER():TIMER(0,MICROSECONDI){}
boolean TICK(){
if(NON_ABILITATO){ABILITA(); NON_ABILITATO=0;}
if(STOP()){
ABILITA();
return 1;
}
return 0;
}
};

enum MODALITA_RESISTENZA{RESISTENZA_ESTERNA,PULLUP,PULLDOWN}
enum MODALITA_LETTURA_DIGITALE{NORMALE,INVERTITA};
class ENTRATA{
protected:
    uint8_t PIN;
    MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE;
public:
    void RESISTENZA_ESTERNA(){M_RESISTENZA=RESISTENZA_ESTERNA; pinMode(PIN,INPUT);}
    void PULLUP(){M_RESISTENZA=PULLUP; pinMode(PIN,INPUT_PULLUP);}
    void PULLDOWN(){M_RESISTENZA=PULLDOWN; digitalWrite(PIN,0);}
protected:
    void IMPOSTA_PIN(uint8_t PIN){this->PIN=PIN; RESISTENZA_ESTERNA();}
    void IMPOSTA_MODALITA_RESISTENZA(MODALITA_RESISTENZA M_RESISTENZA){
     switch(M_RESISTENZA){
        case RESISTENZA_ESTERNA:
            RESISTENZA_ESTERNA();
            break;
        case PULLUP:
            PULLUP();
            break;
        case PULLDOWN:
            PULLDOWN();
            break;
           }
    }
    void IMPOSTA_MODALITA_LETTURA_DIGITALE(MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE){
        this->M_LETTURA_DIGITALE=M_LETTURA_DIGITALE;
    }
public:
    ENTRATA(){}
    ENTRATA(uint8_t PIN){IMPOSTA_PIN(PIN);}
    ENTRATA(uint8_t PIN,MODALITA_RESISTENZA M_RESISTENZA){
     IMPOSTA_MODALITA_RESISTENZA(M_RESISTENZA);
     IMPOSTA_PIN(PIN);
    }
    ENTRATA(uint8_t PIN,MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE){
     IMPOSTA_MODALITA_LETTURA_DIGITALE(M_LETTURA_DIGITALE);
     IMPOSTA_PIN(PIN);
    }
    ENTRATA(uint8_t PIN,MODALITA_RESISTENZA M_RESISTENZA,MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE){
     IMPOSTA_MODALITA_RESISTENZA(M_RESISTENZA);
     IMPOSTA_MODALITA_LETTURA_DIGITALE(M_LETTURA_DIGITALE);
     IMPOSTA_PIN(PIN);
    }
    boolean LETTURA_DIGITALE(){
    boolean L=digitalRead(PIN);
    switch(MODALITA_LETTURA_DIGITALE){
        case NORMALE:
            return L;
            break;
        case INVERTITA:
            return !L;
            break;
        }
    }
    uint16_t LETTURA_ANALOGICA(){return analogRead(PIN);}
};

enum ENUM_SALVA_STATO:boolean{NON_SALVARE_LO_STATO=0,SALVA_STATO=1};
enum TIPO_USCITA:boolean{NORMALE=0,INVERTITA=1}
class USCITA{
protected:
    uint8_t PIN;
    CICLO_TIMER CICLO;
    TIPO_USCITA TIPO;
    ENUM_SALVA_STATO SALVA;
    void IMPOSTA_PIN(uint8_t PIN){this->PIN=PIN; pinMode(PIN,OUTPUT);}
public:
    void IMPOSTA_STATO(boolean STATO){
     switch(TIPO){
        case NORMALE:
            digitalWrite(PIN,STATO);
            break;
        case INVERTITA:
            digitalWrite(PIN,!STATO);
            break;
        }
    if(SALVA){EEPROM.update(PIN,digitalRead(PIN));}
    }
    USCITA(){}
    USCITA(uint8_t PIN){IMPOSTA_PIN(PIN);}
    USCITA(uint8_t PIN,TIPO_USCITA TIPO){
     this->TIPO=TIPO;
     IMPOSTA_PIN(PIN);
    }
    USCITA(uint8_t PIN,ENUM_SALVA_STATO SALVA){
     this->SALVA=SALVA;
     IMPOSTA_PIN(PIN);
     IMPOSTA_STATO(EEPROM.read(PIN));
    }
    USCITA(uint8_t PIN,TIPO_USCITA TIPO,ENUM_SALVA_STATO SALVA){
     this->TIPO=TIPO;
     this->SALVA=SALVA;
     IMPOSTA_PIN(PIN);
     IMPOSTA_STATO(EEPROM.read(PIN));
    }
    void ACCENDI(){IMPOSTA_STATO(1);}
    void SPEGNI(){IMPOSTA_STATO(0);}
    void INVERTI_STATO(){digitalWrite(PIN,!digitalRead(PIN));}
    void LAMPEGGIO(uint16_t RITARDO,UNITA_DI_TEMPO UNITA){
     if(CICLO.INIZIALIZZATO == 0){CICLO = CICLO_TIMER(RITARDO,UNITA);}
     if(CICLO.TICK()){INVERTI_STATO();}
    }
    void PULSAZIONE(uint16_t RITARDO,UNITA_DI_TEMPO UNITA){
     if(CICLO.INIZIALIZZATO == 0){CICLO = CICLO_TIMER(RITARDO,UNITA);}
     if(CICLO.TICK()){ }
    }
};

class LED:public USCITA {
public:
    LED(){}
    LED(uint8_t PIN):USCITA(PIN){}
    LED(uint8_t PIN,TIPO_USCITA TIPO):USCITA(PIN,TIPO_USCITA TIPO){}
    LED(uint8_t PIN,ENUM_SALVA_STATO SALVA):USCITA(PIN,SALVA){}
    LED(uint8_t PIN,TIPO_USCITA TIPO,ENUM_SALVA_STATO SALVA):USCITA(PIN,TIPO,SALVA){}
};

class LED_RGB{
public:
    LED VERDE();
    LED ROSSO();
    LED BLU();
    LED_RGB(){}
    LED_RGB(uint8_t PIN_VERDE,uint8_t PIN_ROSSO,uint8_t PIN_BLU){
     VERDE = LED(PIN_VERDE);
     ROSSO = LED(PIN_ROSSO);
     BLU = LED(PIN_BLU);
    }
    LED_RGB(uint8_t PIN_VERDE,uint8_t PIN_ROSSO,uint8_t PIN_BLU,ENUM_SALVA_STATO SALVA){
     VERDE = LED(PIN_VERDE,SALVA);
     ROSSO = LED(PIN_ROSSO,SALVA);
     BLU = LED(PIN_BLU,SALVA);
    }
    
};

enum TIPO_RELE:TIPO_USCITA{NORMALE=TIPO_USCITA::NORMALE,LOGICA_INVERSA=INVERTITA};
class RELE:USCITA{
 public:
  String STANZA;
  RELE(uint8_t PIN,TIPO_RELE TIPO,String STANZA):USCITA(PIN,TIPO){this->STANZA = STANZA;}
  void ACCESO(){ACCENDI();}
  void SPENTO(){SPEGNI();}
  void INVERTI_STATO(){USCITA::INVERTI_STATO();}
  void LAMPEGGIO(){USCITA::LAMPEGGIO();}
};

enum TIPO_TERMOSTATO{
  RISCALDAMENTO,RAFFREDDAMENTO
};
class TERMOSTATO:RELE {
  protected:
   TIPO_TERMOSTATO TIPO_T;
  public:
  uint8_t SOGLIA_TEMPERATURA=20;
TERMOSTATO(uint8_t PIN_R,TIPO_RELE TIPORELE,TIPO_TERMOSTATO TIPO_T):RELE(PIN_R,TIPORELE,""){this->TIPO_T=TIPO_T;}
void FUNZIONE_TERMOSTATO(uint8_t TEMPERATURA_ATTUALE){
 switch(TIPO_T){
  case RISCALDAMENTO:
   if(TEMPERATURA_ATTUALE<SOGLIA_TEMPERATURA){ACCESO();} else{SPENTO();}
   break;
  case RAFFREDDAMENTO:
   if(TEMPERATURA_ATTUALE>SOGLIA_TEMPERATURA){ACCESO();} else {SPENTO();}
}
}
};

class PULSANTE:ENTRATA,CICLO_TIMER{
 protected:
  boolean STATO_PRECEDENTE;
 public:
    PULSANTE(){}
    PULSANTE(uint8_t PIN,unsigned long RITARDO,UNITA_DI_TEMPO UNITA):ENTRATA(PIN),CICLO_TIMER(RITARDO,UNITA){}
    PULSANTE(uint8_t PIN,unsigned long RITARDO,UNITA_DI_TEMPO UNITA,MODALITA_RESISTENZA M_RESISTENZA):ENTRATA(PIN,M_RESISTENZA),CICLO_TIMER(RITARDO,UNITA){}
    PULSANTE(uint8_t PIN,unsigned long RITARDO,UNITA_DI_TEMPO UNITA,MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE):ENTRATA(PIN,M_LETTURA_DIGITALE),CICLO_TIMER(RITARDO,UNITA){}
    PULSANTE(uint8_t PIN,unsigned long RITARDO,UNITA_DI_TEMPO UNITA,MODALITA_RESISTENZA M_RESISTENZA,
    MODALITA_LETTURA_DIGITALE M_LETTURA_DIGITALE):ENTRATA(PIN,M_RESISTENZA,M_LETTURA_DIGITALE),CICLO_TIMER(RITARDO,UNITA){}
  boolean CLICCATO(){
   if(TICK()){
     if(STATO_PRECEDENTE && LETTURA_DIGITALE()){
       STATO_PRECEDENTE=0;
       return 1;
      }
   }
   if(LETTURA_DIGITALE() && STATO_PRECEDENTE==0){STATO_PRECEDENTE=1;}
   return 0;
  }
  void RESISTENZA_ESTERNA() override {ENTRATA::RESISTENZA_ESTERNA();}
  void PULLUP() override {ENTRATA::PULLUP()}
  void PULLDOWN() override {ENTRATA::PULLDOWN()}
};

class FOTORESISTORE:ENTRATA,CICLO_TIMER {
protected:
uint16_t SOGLIA_ACCENSIONE;
uint16_t SOGLIA_SPEGNIMENTO;
boolean ULTIMO_CONTROLLO_ESEGUITO;
public:
FOTORESISTORE(uint8_t PIN,uint16_t SOGLIA_ACCENSIONE,uint16_t SOGLIA_SPEGNIMENTO,unsigned long RITARDO,UNITA_DI_TEMPO UNITA):ENTRATA(PIN),CICLO_TIMER(RITARDO,UNITA){
this->SOGLIA_ACCENSIONE = SOGLIA_ACCENSIONE;
this->SOGLIA_SPEGNIMENTO = SOGLIA_SPEGNIMENTO;
}
uint16_t LEGGI_FOTORESISTORE(){return LETTURA_ANALOGICA();}
boolean CONTROLLO(){
if(TICK()){
if(LEGGI_FOTORESISTORE()>=SOGLIA_ACCENSIONE){ULTIMO_CONTROLLO_ESEGUITO=1; return 1;}
if(LEGGI_FOTORESISTORE()<=SOGLIA_ACCENSIONE && LEGGI_FOTORESISTORE()>=SOGLIA_SPEGNIMENTO){ return ULTIMO_CONTROLLO_ESEGUITO;}
ULTIMO_CONTROLLO_ESEGUITO=0;
return 0;
}
return ULTIMO_CONTROLLO_ESEGUITO;
}
};

class CREPUSCOLARE:RELE,FOTORESISTORE{
public:
CREPUSCOLARE(uint8_t PIN_FOTORESISTORE,uint16_t SOGLIA_ACCENSIONE,uint16_t SOGLIA_SPEGNIMENTO,uint16_t RITARDO,UNITA_DI_TEMPO UNITA,
uint8_t PIN_RELE,TIPO_RELE TIPORELE):FOTORESISTORE(PIN_FOTORESISTORE,SOGLIA_ACCENSIONE,SOGLIA_SPEGNIMENTO,RITARDO,UNITA),
RELE(PIN_RELE,TIPORELE,"ESTERNO"){}
void FUNZIONE_CREPUSCOLARE(){
  if(CONTROLLO()){ACCESO();}
  else{SPENTO();}
}
};

class BLUETOOTH {
public:
String RISULTATO_ASCOLTO;
BLUETOOTH(int baud_rate){Serial.begin(baud_rate);}
void ASCOLTO(){
  if(Serial.available()){
    RISULTATO_ASCOLTO = Serial.readString();
  }
}
void INVIO(String V){
Serial.print(V);
}
};

class INGRESSO_MONITORATO{
 public:
   uint16_t FINECORSA_APERTURA;
   uint16_t FINECORSA_CHIUSURA;
   virtual boolean APERTO();
   virtual boolean CHIUSO();
};

class INGRESSO_FISICO:INGRESSO_MONITORATO{
 protected:
  PULSANTE PULSANTE_FINECORSA_APERTURA;
  PULSANTE PULSANTE_FINECORSA_CHIUSURA;
 public:
  INGRESSO_FISICO(uint8_t PIN_FINECORSA_APERTURA,uint8_t PIN_FINECORSA_CHIUSURA,unsigned long RITARDO_FINECORSA1,UNITA_DI_TEMPO UNITA_FINECORSA1,
  unsigned long RITARDO_FINECORSA2,UNITA_DI_TEMPO UNITA_FINECORSA2){
  PULSANTE_FINECORSA_APERTURA = PULSANTE(PIN_FINECORSA_APERTURA,RITARDO_FINECORSA1,UNITA_FINECORSA1);
  PULSANTE_FINECORSA_CHIUSURA = PULSANTE(PIN_FINECORSA_CHIUSURA,RITARDO_FINECORSA2,UNITA_FINECORSA2);
  }
 boolean APERTO() override {return PULSANTE_FINECORSA_APERTURA.CLICCATO();}
 boolean CHIUSO() override {return PULSANTE_FINECORSA_CHIUSURA.CLICCATO();}
};

enum STATO_DEL_MOVIMENTO:uint8_t{CHIUSURA=0,APERTURA=1};
class STATO_MOVIMENTO{
 public:
  uint16_t INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO;
  void MEMORIZZA_STATO(STATO_DEL_MOVIMENTO STATO){
   EEPROM.update(INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO,STATO);
   }
  virtual APRI();
  virtual CHIUDI();
  void CONTROLLO_STATO_MOVIMENTO(){
    STATO_DEL_MOVIMENTO STATO;
    EEPROM.get(INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO,STATO);
    switch(STATO){
        case CHIUSURA:
            CHIUDI();
        case APERTURA:
            APRI();
        }
    }
};

class INGRESSO_MOTORIZZATO:public INGRESSO_MONITORATO,public STATO_MOVIMENTO{};

class MOTORE_SWIPING{
public:
    CICLO_TIMER CICLO;
    virtual uint16_t POSIZIONE_CORRENTE();
    virtual SWIPE_AVANTI();
    virtual SWIPE_INDIETRO();
    void SWIPING(uint16_t TEMPO_DA_FERMO, UNITA_DI_TEMPO UNITA){
     if(CICLO.INIZIALIZZATO == 0){CICLO = CICLO_TIMER(TEMPO_DA_FERMO,UNITA);}
    if(CICLO.TICK() && CICLO.INIZIALIZZATO){
     if(POSIZIONE_CORRENTE() == GRADI_GIU) {AVANTI();}
     else if(POSIZIONE_CORRENTE() == GRADI_SU){INDIETRO();}
     }
    }
};

class SERVOMOTORE:Servo,MOTORE_SWIPING{
 protected:
    uint8_t PIN;
    byte INDIRIZZO_EEPROM_GRADI;
    byte GRADI_AVANTI;
    byte GRADI_INDIETRO;
    uint16_t RITARDO_SPOSTAMENTO_SWIPING_IN_MILLISECONDI;
  void SCRIVI_POSIZIONE(byte GRADI){
    write(GRADI);
    EEPROM.put(INDIRIZZO_EEPROM_GRADI,GRADI);
  }
  void AUMENTA_POSIZIONE(byte GRADI,uint16_t RITARDO_IN_MILLISECONDI){
   for(uint16_t P=POSIZIONE_CORRENTE();P<GRADI;P++){
    SCRIVI_POSIZIONE(P);
    delay(RITARDO_IN_MILLISECONDI);
    }
  }
  void DIMINUISCI_POSIZIONE(byte GRADI,uint16_t RITARDO_IN_MILLISECONDI){
    for(uint16_t P=POSIZIONE_CORRENTE();P>GRADI;P--){
    SCRIVI_POSIZIONE(P);
    delay(RITARDO_IN_MILLISECONDI);
    }
  }
  void ATTACCA(){
   attach(PIN);
   write(POSIZIONE_CORRENTE());
   }
  void SWIPE_AVANTI() override {
    IMPOSTA_POSIZIONE(GRADI_AVANTI, RITARDO_SPOSTAMENTO_SWIPING_IN_MILLISECONDI);
    }
  void SWIPE_INDIETRO() override {
    IMPOSTA_POSIZIONE(GRADI_INDIETRO, RITARDO_SPOSTAMENTO_SWIPING_IN_MILLISECONDI);
    }
 public:
  byte POSIZIONE_CORRENTE(){return EEPROM.read(INDIRIZZO_EEPROM_GRADI);}
  SERVOMOTORE(uint8_t PIN):Servo(){
  this->INDIRIZZO_EEPROM_GRADI=PIN;
  this->PIN = PIN;
  /*NON SI PUO USARE LA FUNZIONE "attach" PRIMA DEL SETUP,
  IPOTIZZO CHE PRIMA DEL SETUP NON VENGONO INIZIALIZZATE LE FUNZIONI PRINCIPALI DELL'AMBIENTE DI SVILUPPO,
  QUINDI VERRA ESEGUITO LA PRIMA VOLTA CHE SI IMPOSTA LA POSIZIONE*/
  }
  void IMPOSTA_POSIZIONE(uint16_t GRADI,uint16_t RITARDO_IN_MILLISECONDI){
    if(attached()==0){ATTACCA();}
    if(RITARDO_IN_MILLISECONDI>0){
    AUMENTA_POSIZIONE(GRADI,RITARDO_IN_MILLISECONDI);
    DIMINUISCI_POSIZIONE(GRADI,RITARDO_IN_MILLISECONDI);
   }
   else{SCRIVI_POSIZIONE(GRADI);}
  }
    void SWIPING(byte GRADI_AVANTI, byte GRADI_INDIETRO, uint16_t RITARDO_SPOSTAMENTO_IN_MILLISECONDI,uint16_t TEMPO_DA_FERMO, UNITA_DI_TEMPO UNITA){
        this->GRADI_AVANTI = GRADI_AVANTI;
        this->GRADI_INDIETRO = GRADI_INDIETRO;
        RITARDO_SPOSTAMENTO_SWIPING_IN_MILLISECONDI = RITARDO_SPOSTAMENTO_IN_MILLISECONDI;
        SWIPING(TEMPO_DA_FERMO,UNITA);
    }
};

class SERVO_INGRESSO:SERVOMOTORE,INGRESSO_MOTORIZZATO{
  protected:
   uint16_t RITARDO_MOVIMENTO_IN_MILLISECONDI;
  public:
   void APRI() override {
    MEMORIZZA_STATO(APERTURA);
    IMPOSTA_POSIZIONE(FINECORSA_APERTURA,RITARDO_MOVIMENTO_IN_MILLISECONDI);
   }
   void CHIUDI() override {
    MEMORIZZA_STATO(CHIUSURA);
    IMPOSTA_POSIZIONE(FINECORSA_CHIUSURA,RITARDO_MOVIMENTO_IN_MILLISECONDI);
   }
   boolean APERTO() override {return POSIZIONE_CORRENTE()==FINECORSA_APERTURA;}
   boolean CHIUSO() override {return POSIZIONE_CORRENTE()==FINECORSA_CHIUSURA;}
   SERVO_INGRESSO(uint8_t PIN,uint16_t INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO,uint16_t POSIZIONE_APERTURA,uint16_t POSIZIONE_CHIUSURA,
   uint16_t RITARDO_MOVIMENTO_IN_MILLISECONDI):SERVOMOTORE(PIN){
   this->RITARDO_MOVIMENTO_IN_MILLISECONDI = RITARDO_MOVIMENTO_IN_MILLISECONDI;
   INGRESSO_MOTORIZZATO::INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO = INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO;
   FINECORSA_APERTURA = POSIZIONE_APERTURA;
   FINECORSA_CHIUSURA = POSIZIONE_CHIUSURA;
   CONTROLLO_STATO_MOVIMENTO();
   }
   
};

class MOTORE_STEPPER_BASE:MOTORE_SWIPING{
protected:
 uint16_t PASSI_MASSIMI;
 uint16_t INDIRIZZO_POSIZIONE_EEPROM;
 uint8_t VELOCITA;
 void MEMORIZZA_PASSI(uint16_t PASSI){EEPROM.put(INDIRIZZO_POSIZIONE_EEPROM,PASSI);}
public:
  void IMPOSTA_VELOCITA(uint8_t VELOCITA){this->VELOCITA=VELOCITA;}
  MOTORE_STEPPER_BASE(uint16_t STEP_MASSIMI,uint8_t VELOCITA,uint16_t INDIRIZZO_POSIZIONE_EEPROM){
  this->STEP_MASSIMI=STEP_MASSIMI;
  this->INDIRIZZO_POSIZIONE_EEPROM = INDIRIZZO_POSIZIONE_EEPROM;
  IMPOSTA_VELOCITA(VELOCITA);
  }
  uint16_t POSIZIONE_CORRENTE(){
     uint16_t R;
     EEPROM.get(INDIRIZZO_POSIZIONE_EEPROM,R);
     return R;
    }
  virtual void PASSO();
  virtual void SINISTRA();
  virtual void DESTRA();
  void PASSI(uint16_t PASSI){for(uint16_t P; P<PASSI; P++){PASSO();} MEMORIZZA_PASSI(PASSI);}
protected:
  uint16_t PASSI_AVANTI;
  uint16_t PASSI_INDIETRO;
  void SWIPE_AVANTI() override {PASSI(PASSI_AVANTI);}
  void SWIPE_INDIETRO() override {PASSI(PASSI_INDIETRO);}
public:
  void SWIPING(uint16_t PASSI_AVANTI,uint16_t PASSI_INDIETRO,uint16_t TEMPO_DA_FERMO, UNITA_DI_TEMPO UNITA){
      this->PASSI_AVANTI = PASSI_AVANTI;
      this->PASSI_INDIETRO = PASSI_INDIETRO;
      SWIPING(TEMPO_DA_FERMO,UNITA);
  }
};

class MOTORE_STEPPER: public MOTORE_STEPPER_BASE{
private:
    uint8_t PIN_CONTROLLO_PASSO;
    uint8_t PIN_VERSO;
    boolean STATO_PIN_VERSO_DESTRA;
public:
    MOTORE_STEPPER(uint8_t PIN_CONTROLLO_PASSO,uint8_t PIN_VERSO, boolean STATO_PIN_VERSO_DESTRA, uint16_t PASSI_MASSIMI,uint16_t INDIRIZZO_POSIZIONE_EEPROM,uint8_t VELOCITA):
    MOTORE_STEPPER_BASE(PASSI_MASSIMI,VELOCITA,INDIRIZZO_POSIZIONE_EEPROM){
     this->PIN_CONTROLLO_PASSO=PIN_CONTROLLO_PASSO;
     this->PIN_VERSO=PIN_VERSO;
     pinMode(PIN_CONTROLLO_PASSO,OUTPUT);
     pinMode(PIN_VERSO,OUTPUT);
     }
    void PASSO() override {
        digitalWrite(PIN_CONTROLLO_PASSO,HIGH);
        delay(10);
        digitalWrite(PIN_CONTROLLO_PASSO,LOW);
     }
    void DESTRA() override {digitalWrite(PIN_VERSO,STATO_PIN_VERSO_DESTRA);}
    void SINISTRA() override {digitalWrite(PIN_VERSO,!STATO_PIN_VERSO_DESTRA);}
};

class MOTORE_STEPPER_4_BOBINE:Stepper,public MOTORE_STEPPER_BASE{
  public:
    void IMPOSTA_VELOCITA(uint16_t VELOCITA) override {
    MOTORE_STEPPER_BASE:IMPOSTA_VELOCITA(VELOCITA);
    setSpeed(VELOCITA);
  }
    MOTORE_STEPPER_4_BOBINE(uint16_t PASSI_MASSIMI,uint8_t PIN_BOBINA1,uint8_t PIN_BOBINA2,uint8_t PIN_BOBINA3,uint8_t PIN_BOBINA4,uint16_t VELOCITA,uint16_t INDIRIZZO_POSIZIONE_EEPROM):
     MOTORE_STEPPER_BASE(PASSI_MASSIMI,VELOCITA,INDIRIZZO_POSIZIONE_EEPROM),
     Stepper(PASSI_MASSIMI,PIN_BOBINA1,PIN_BOBINA2,PIN_BOBINA3,PIN_BOBINA4){
     IMPOSTA_VELOCITA(VELOCITA);
  }
    void PASSO() override{step(1);}
};

class STEPPER_INGRESSO_BASE: public INGRESSO_MOTORIZZATO {
    virtual uint16_t POSIZIONE_CORRENTE();
    void APRI() override {
     MEMORIZZA_STATO(APERTURA);
     PASSI(FINECORSA_APERTURA);
    }
    void CHIUDI() override {
     MEMORIZZA_STATO(CHIUSURA);
     PASSI(FINECORSA_CHIUSURA);
    }
    boolean APERTO() override {return POSIZIONE_CORRENTE()==FINECORSA_APERTURA;}
    boolean CHIUSO() override {return POSIZIONE_CORRENTE()==FINECORSA_CHIUSURA;}
}

class STEPPER_INGRESSO:MOTORE_STEPPER,public STEPPER_INGRESSO_BASE{
public:
    uint16_t POSIZIONE_CORRENTE() override {return MOTORE_STEPPER:POSIZIONE_CORRENTE();}
    STEPPER_INGRESSO(uint8_t PIN_CONTROLLO_PASSO,uint8_t PIN_VERSO, boolean STATO_PIN_VERSO_DESTRA, uint16_t PASSI_MASSIMI,uint16_t INDIRIZZO_POSIZIONE_EEPROM,uint8_t VELOCITA,
    uint16_t PASSI_APERTURA,uint16_t PASSI_CHIUSURA,uint16_t INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO):
    MOTORE_STEPPER(PIN_CONTROLLO_PASSO,PIN_VERSO,STATO_PIN_VERSO_DESTRA,PASSI_MASSIMI,INDIRIZZO_POSIZIONE_EEPROM,VELOCITA){
     IMPOSTA_VELOCITA(VELOCITA);
     FINECORSA_APERTURA = PASSI_APERTURA;
     FINECORSA_CHIUSURA = PASSI_CHIUSURA;
     INGRESSO_MOTORIZZATO::INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO = INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO;
     CONTROLLO_STATO_MOVIMENTO();
     }
};

class STEPPER_INGRESSO_4_BOBINE:MOTORE_STEPPER_4_BOBINE,public STEPPER_INGRESSO_BASE{
  public:
    uint16_t POSIZIONE_CORRENTE() override {return MOTORE_STEPPER_4_BOBINE:POSIZIONE_CORRENTE();}
    STEPPER_INGRESSO(uint16_t PASSI_MASSIMI,uint8_t PIN_BOBINA1,uint8_t PIN_BOBINA2,uint8_t PIN_BOBINA3,uint8_t PIN_BOBINA4,
    uint16_t INDIRIZZO_POSIZIONE_EEPROM,uint16_t PASSI_APERTURA,uint16_t PASSI_CHIUSURA,uint8_t VELOCITA,uint16_t INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO):
    MOTORE_STEPPER_4_BOBINE(PASSI_MASSIMI,VELOCITA,PIN_BOBINA1,PIN_BOBINA2,PIN_BOBINA3,PIN_BOBINA4){
     FINECORSA_APERTURA = PASSI_APERTURA;
     FINECORSA_CHIUSURA = PASSI_CHIUSURA;
     INGRESSO_MOTORIZZATO::INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO = INDIRIZZO_POSIZIONE_STATO_DEL_MOVIMENTO;
     CONTROLLO_STATO_MOVIMENTO();
     }
};

class TASTIERA_A_MATRICE{
    
};

class ALLARME:TASTIERA_A_MATRICE{
    
};

#endif
